
# This file is automatically generated, you probably don't want to edit this

jtMergeColsOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtMergeColsOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            varBy = NULL,
            varOth = NULL,
            fleInp = "",
            fleChs = NULL,
            typMrg = "outer",
            btnOut = NULL,
            blnOut = FALSE, ...) {

            super$initialize(
                package="jTransform",
                name="jtMergeCols",
                requiresData=TRUE,
                ...)

            private$..varBy <- jmvcore::OptionVariables$new(
                "varBy",
                varBy,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varOth <- jmvcore::OptionVariables$new(
                "varOth",
                varOth,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..fleInp <- jmvcore::OptionString$new(
                "fleInp",
                fleInp,
                default="")
            private$..fleChs <- jmvcore::OptionString$new(
                "fleChs",
                fleChs,
                hidden=TRUE)
            private$..typMrg <- jmvcore::OptionList$new(
                "typMrg",
                typMrg,
                options=list(
                    "outer",
                    "inner",
                    "left",
                    "right"),
                default="outer")
            private$..btnOut <- jmvcore::OptionString$new(
                "btnOut",
                btnOut,
                hidden=TRUE)
            private$..blnOut <- jmvcore::OptionBool$new(
                "blnOut",
                blnOut,
                default=FALSE,
                hidden=TRUE)

            self$.addOption(private$..varBy)
            self$.addOption(private$..varOth)
            self$.addOption(private$..fleInp)
            self$.addOption(private$..fleChs)
            self$.addOption(private$..typMrg)
            self$.addOption(private$..btnOut)
            self$.addOption(private$..blnOut)
        }),
    active = list(
        varBy = function() private$..varBy$value,
        varOth = function() private$..varOth$value,
        fleInp = function() private$..fleInp$value,
        fleChs = function() private$..fleChs$value,
        typMrg = function() private$..typMrg$value,
        btnOut = function() private$..btnOut$value,
        blnOut = function() private$..blnOut$value),
    private = list(
        ..varBy = NA,
        ..varOth = NA,
        ..fleInp = NA,
        ..fleChs = NA,
        ..typMrg = NA,
        ..btnOut = NA,
        ..blnOut = NA)
)

jtMergeColsResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtMergeColsResults",
    inherit = jmvcore::Group,
    active = list(
        txtPvw = function() private$.items[["txtPvw"]],
        txtInf = function() private$.items[["txtInf"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Add columns (from other data sets)")
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="txtPvw",
                title="Outout Preview"))
            self$add(jmvcore::Html$new(
                options=options,
                name="txtInf",
                refs=list(
                    "jTransform",
                    "jmvReadWrite"),
                content="<h2>Details</h2> <p><strong>Adds columns from other jamovi data file(s) to the current data set (matching them by one or more ID variables).</strong></p> <p>Assign one or more variables that appear in all data sets (e.g., with a participant code) to \u201CVariable(s) to match the data sets by\u201D. Afterwards, you need to assign the remaining variables (i.e., those that you do not want to exclude from the output data file) to \u201CFurther variables in the output\u201D.</p> <p>The file browser under \u201CData set(s) to add\u201D represents a \u201Ctweaked\u201D solution: Because it only delivers the file name back, the home directory is afterwards searched for those file name(s). If a file can't be located in the home directory, or if it exists in more than one locations inside the home directory, an error is returned. Although it is less convenient, manually providing the file name including the path may therefore be both quicker and less error-prone. If several file names are provided, they have to be separated by semicolons.</p> <p>There are four different types of merging operations: The first option keeps all cases (but columns in the resulting data set may be empty if they did not contain values in same input data sets), the second option keeps only those cases where all datasets contain the same value in the matching variable, for \"left\" all cases from the first data set in fleInp are kept (whereas cases that are only contained in input data set two or higher are dropped), for \"right\" all cases from the second (or any higher) data set in fleInp are kept.</p>\n"))}))

jtMergeColsBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtMergeColsBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jTransform",
                name = "jtMergeCols",
                version = c(1,0,0),
                options = options,
                results = jtMergeColsResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = TRUE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Add columns (from other data sets)
#'
#' Add columns (from other data sets)
#'
#' @examples
#' \dontrun{
#' # the function is a wrapper for jmvReadWrite::merge_cols_omv
#' # please use that function from R
#' # for more information: https://sjentsch.github.io/jmvReadWrite
#'}
#' @param data the data as a data frame
#' @param varBy .
#' @param varOth .
#' @param fleInp .
#' @param fleChs .
#' @param typMrg .
#' @param btnOut .
#' @param blnOut .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$txtPvw} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$txtInf} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' @export
jtMergeCols <- function(
    data,
    varBy,
    varOth,
    fleInp = "",
    fleChs,
    typMrg = "outer",
    btnOut,
    blnOut = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("jtMergeCols requires jmvcore to be installed (restart may be required)")

    if ( ! missing(varBy)) varBy <- jmvcore::resolveQuo(jmvcore::enquo(varBy))
    if ( ! missing(varOth)) varOth <- jmvcore::resolveQuo(jmvcore::enquo(varOth))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(varBy), varBy, NULL),
            `if`( ! missing(varOth), varOth, NULL))


    options <- jtMergeColsOptions$new(
        varBy = varBy,
        varOth = varOth,
        fleInp = fleInp,
        fleChs = fleChs,
        typMrg = typMrg,
        btnOut = btnOut,
        blnOut = blnOut)

    analysis <- jtMergeColsClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

