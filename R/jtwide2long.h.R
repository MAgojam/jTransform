
# This file is automatically generated, you probably don't want to edit this

jtWide2LongOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtWide2LongOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            varID = NULL,
            varLst = NULL,
            varExc = NULL,
            varTme = "cond",
            varSep = "_",
            excLvl = "",
            btnOut = NULL,
            blnOut = FALSE, ...) {

            super$initialize(
                package="jTransform",
                name="jtWide2Long",
                requiresData=TRUE,
                ...)

            private$..varID <- jmvcore::OptionVariables$new(
                "varID",
                varID,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varLst <- jmvcore::OptionVariables$new(
                "varLst",
                varLst,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varExc <- jmvcore::OptionVariables$new(
                "varExc",
                varExc,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varTme <- jmvcore::OptionString$new(
                "varTme",
                varTme,
                default="cond")
            private$..varSep <- jmvcore::OptionString$new(
                "varSep",
                varSep,
                default="_")
            private$..excLvl <- jmvcore::OptionString$new(
                "excLvl",
                excLvl,
                default="")
            private$..btnOut <- jmvcore::OptionString$new(
                "btnOut",
                btnOut,
                hidden=TRUE)
            private$..blnOut <- jmvcore::OptionBool$new(
                "blnOut",
                blnOut,
                default=FALSE,
                hidden=TRUE)

            self$.addOption(private$..varID)
            self$.addOption(private$..varLst)
            self$.addOption(private$..varExc)
            self$.addOption(private$..varTme)
            self$.addOption(private$..varSep)
            self$.addOption(private$..excLvl)
            self$.addOption(private$..btnOut)
            self$.addOption(private$..blnOut)
        }),
    active = list(
        varID = function() private$..varID$value,
        varLst = function() private$..varLst$value,
        varExc = function() private$..varExc$value,
        varTme = function() private$..varTme$value,
        varSep = function() private$..varSep$value,
        excLvl = function() private$..excLvl$value,
        btnOut = function() private$..btnOut$value,
        blnOut = function() private$..blnOut$value),
    private = list(
        ..varID = NA,
        ..varLst = NA,
        ..varExc = NA,
        ..varTme = NA,
        ..varSep = NA,
        ..excLvl = NA,
        ..btnOut = NA,
        ..blnOut = NA)
)

jtWide2LongResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtWide2LongResults",
    inherit = jmvcore::Group,
    active = list(
        txtPvw = function() private$.items[["txtPvw"]],
        txtInf = function() private$.items[["txtInf"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Transform dataset from wide to long")
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="txtPvw",
                title="Outout Preview"))
            self$add(jmvcore::Html$new(
                options=options,
                name="txtInf",
                refs=list(
                    "jTransform",
                    "jmvReadWrite"),
                content="<h2>Details</h2> <p><strong>This function transforms a dataset from wide to long format.</strong></p> <p>\u201CVariables that identify the same unit\u201D is an ID variable (e.g., a participant code). This code needs to be unique (i.e., there can't be two participants, or other units, with the same ID).</p> <p>\u201CVariables to be transformed\u201D are the so-called target variables, i.e., variables that exist as many columns in the input data set and are going to be transformed, creating different steps of one or more time-varying variable resulting in the output. How many variables are created is determined by how many parts the variable name has (the parts are split by the character defined as \u201CSeparator\u201D) and how many steps / different values exist within each part. If we had a variable with 4 parts, each with two steps per step, this would result in four columns (starting with the string defined as \u201CPrefix\u201D and ending with 1, 2, 3, and 4). The number of rows would be increased by the number of all possible combinations of steps (in the example above 2 * 2 * 2 * 2 = 16, mulitiplied by the number of rows in the input data set, e.g., 50 rows becoming 50 * 16 = 800 rows).</p> <p>\u201CVariables NOT to be transformed\u201D are variables that \u201Ccharacterize\u201D a participant (or another unit), often also called between-subjects variables, e.g., age or sex. However, they are not unique (and thus no ID variables; there may be several participant with the same age or sex).</p> <p>\u201CSeparator\u201D defines which character(s) should be placed between the target variable and the steps of the time-varying variable / conditions when assembling the variable names (e.g., VAR_COND).</p> <p>Often, an input data set contains different types of measures (e.g., whether a response was correct and the reaction time) that make up a part of the variable name. Typically, one wants to keep those different measures as separate columns in the output data set. \"Exclude level\" permits to exclude one (or more) part (in the steps in it) from being transformed from wide to long. If the measurement types were the first part of the variable name, 1 would have to be put into this field. If all levels are to be transformed, the field needs to be blank.</p> <p></p> <p>The principle of the transformation from long to wide can perhaps easiest be understood by looking at example4jtWide2Long from the Data Library of this module. It contains results from a Stroop experiment (in wide format) with fifty variables: ID (identifies the participant), sex (of the participant), and afterwards 48 variables that represent a combination of the measurement (first part of the variable name, rspCrr \u2013 whether the response was correct \u2013 or rspTme \u2013 reaction time), the experimental condition / congruency (second part; either cong[ruent], incong[ruent] or neutral), the colour the word was written with (third part; BLUE, GREEN, RED or YELLOW) and which repetition of a particular combination of experimental conditions the variable represents (fourth part, 1 or 2). These variables have to be assigned to the following fields: ID to \u201CVariables that identify the same unit\u201D (it is an unique identifier of each participant); sex to \u201CVariables NOT to be transformed\u201D (sex is a between-subjects variable that doesn't change between experimental conditions; however, it is not unique and thus not suited as ID variable); and the remaining variables (i.e., all variables starting with rspCrr_... or rspTme... to \u201CVariables to be transformed\u201D. Under \u201CPrefix\u201D it can be determined how the name for the different conditions shall start (a number would be added if there is more than one condition).</p>\n"))}))

jtWide2LongBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtWide2LongBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jTransform",
                name = "jtWide2Long",
                version = c(1,0,0),
                options = options,
                results = jtWide2LongResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = TRUE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Transform dataset from wide to long
#'
#' Transform dataset from wide to long
#'
#' @examples
#' \dontrun{
#' # the function is a wrapper for jmvReadWrite::wide2long_omv
#' # please use that function when using R
#' # for more information: https://sjentsch.github.io/jmvReadWrite
#'}
#' @param data .
#' @param varID .
#' @param varLst .
#' @param varExc .
#' @param varTme .
#' @param varSep .
#' @param excLvl .
#' @param btnOut .
#' @param blnOut .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$txtPvw} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$txtInf} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' @export
jtWide2Long <- function(
    data,
    varID,
    varLst,
    varExc,
    varTme = "cond",
    varSep = "_",
    excLvl = "",
    btnOut,
    blnOut = FALSE) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("jtWide2Long requires jmvcore to be installed (restart may be required)")

    if ( ! missing(varID)) varID <- jmvcore::resolveQuo(jmvcore::enquo(varID))
    if ( ! missing(varLst)) varLst <- jmvcore::resolveQuo(jmvcore::enquo(varLst))
    if ( ! missing(varExc)) varExc <- jmvcore::resolveQuo(jmvcore::enquo(varExc))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(varID), varID, NULL),
            `if`( ! missing(varLst), varLst, NULL),
            `if`( ! missing(varExc), varExc, NULL))


    options <- jtWide2LongOptions$new(
        varID = varID,
        varLst = varLst,
        varExc = varExc,
        varTme = varTme,
        varSep = varSep,
        excLvl = excLvl,
        btnOut = btnOut,
        blnOut = blnOut)

    analysis <- jtWide2LongClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

