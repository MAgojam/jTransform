
# This file is automatically generated, you probably don't want to edit this

jtLong2WideOptions <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtLong2WideOptions",
    inherit = jmvcore::Options,
    public = list(
        initialize = function(
            varID = NULL,
            varTme = NULL,
            varTgt = NULL,
            varExc = NULL,
            varOrd = "times",
            varAgg = "mean",
            varSep = "_",
            btnOut = NULL, ...) {

            super$initialize(
                package="jTransform",
                name="jtLong2Wide",
                requiresData=TRUE,
                ...)

            private$..varID <- jmvcore::OptionVariables$new(
                "varID",
                varID,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varTme <- jmvcore::OptionVariables$new(
                "varTme",
                varTme,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varTgt <- jmvcore::OptionVariables$new(
                "varTgt",
                varTgt,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varExc <- jmvcore::OptionVariables$new(
                "varExc",
                varExc,
                permitted=list(
                    "numeric",
                    "factor",
                    "id"))
            private$..varOrd <- jmvcore::OptionList$new(
                "varOrd",
                varOrd,
                options=list(
                    "times",
                    "vars"),
                default="times")
            private$..varAgg <- jmvcore::OptionList$new(
                "varAgg",
                varAgg,
                options=list(
                    "mean",
                    "first"),
                default="mean")
            private$..varSep <- jmvcore::OptionString$new(
                "varSep",
                varSep,
                default="_")
            private$..btnOut <- jmvcore::OptionAction$new(
                "btnOut",
                btnOut)

            self$.addOption(private$..varID)
            self$.addOption(private$..varTme)
            self$.addOption(private$..varTgt)
            self$.addOption(private$..varExc)
            self$.addOption(private$..varOrd)
            self$.addOption(private$..varAgg)
            self$.addOption(private$..varSep)
            self$.addOption(private$..btnOut)
        }),
    active = list(
        varID = function() private$..varID$value,
        varTme = function() private$..varTme$value,
        varTgt = function() private$..varTgt$value,
        varExc = function() private$..varExc$value,
        varOrd = function() private$..varOrd$value,
        varAgg = function() private$..varAgg$value,
        varSep = function() private$..varSep$value,
        btnOut = function() private$..btnOut$value),
    private = list(
        ..varID = NA,
        ..varTme = NA,
        ..varTgt = NA,
        ..varExc = NA,
        ..varOrd = NA,
        ..varAgg = NA,
        ..varSep = NA,
        ..btnOut = NA)
)

jtLong2WideResults <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtLong2WideResults",
    inherit = jmvcore::Group,
    active = list(
        txtPvw = function() private$.items[["txtPvw"]],
        txtInf = function() private$.items[["txtInf"]]),
    private = list(),
    public=list(
        initialize=function(options) {
            super$initialize(
                options=options,
                name="",
                title="Transform dataset from long to wide")
            self$add(jmvcore::Preformatted$new(
                options=options,
                name="txtPvw",
                title="Output Preview",
                clearWith=list()))
            self$add(jmvcore::Html$new(
                options=options,
                name="txtInf",
                refs=list(
                    "jTransform",
                    "jmvReadWrite"),
                clearWith=list(),
                content="<h2>Details</h2> <p><strong>This function transforms a dataset from long to wide format. </strong></p> <p>\u201CVariables that identify the same unit\u201D is an ID variable (e.g., a participant code). This code needs to be unique (i.e., there can't be two participants, or other units, with the same ID).</p> <p> \u201CVariables that differentiate within an unit\u201D are the so-called time-varying variables, i.e., variables that are originally are arranged in rows and whose steps shall be transformed into columns (a new column created for the each combination of a target variable, e.g., reaction time [RT], with each experimental condition [cond\u2026] leading RT_cond1, RT_cond2, \u2026). There can be several time-varying variables (e.g., several facors in an experiment, each represented by a different column in the input data set).</p> <p>\u201CVariables to be transformed\u201D are the so-called target variables, i.e., variables that exist as one column in the input data set and are going to be transformed / combined with each step of a time-varying variable resulting in as many columns as there are steps (e.g., would reaction time be one column in the input data set, resulting in as many columns as there are different combinations of time-varying variables in the output data set; if there are 3 steps on the first time-varying variable and 4 steps on the second, this would result in 12 columns in the output data set).</p> <p>\u201CVariables NOT to be transformed\u201D are variables that \u201Ccharacterize\u201D a participant (or another unit), often also called between-subjects variables, e.g., age or sex. However, they are not unique (and thus no ID variables; there may be several participant with the same age or sex).</p> <p>\u201CVariable organization in the output\u201D determines how the variables are to be arranged in the output data set. This is only relevant if there is more than one target variable (e.g., if you want to transform both correct responses and reaction times). \u201CVariables are adjacent\u201D keeps the target variables in adjacent columns (for the example above, correct responses and reaction time would be adjacent, and on the higher levels, the steps of the time-varying variable / conditions would vary). \u201CTime steps are adjacent\u201D would produce a block where all steps of the time-varying variable / conditions for the first target variable are adjacent, followed by a block of all conditions of the second variable and so on.</p> <p>\u201CHow to accumulate?\u201D determines how different rows may be accumulated. The setting does not apply if there is only one occurence / row for each possible combination of conditions. Let's assume that you ran an experiment with two factors: the experimental condition and which repetition of that condition an entry represents. For evaluation, you want to drop the repetition (you thus only assign the variable representing the condition to \u201CVariables that differentiate within an unit\u201D. The setting determines whether the mean of the repetitions shall be taken or the first occurence of each condition.</p> <p>\u201CSeparator\u201D defines which character(s) should be placed between the target variable and the steps of the time-varying variable / conditions when assembling the variable names (e.g., VAR_COND).</p> <p></p> <p>The principle of the transformation from long to wide can perhaps easiest be understood by looking at example4jtLong2Wide from the Data Library of this module. It contains results from a Stroop experiment (in long format) with seven variables: ID (identifies the participant), sex (of the participant), cond (of the Stroop experiment; congruent, neutral, and incongruent), colour (in which the target word was written), rep (which repetition of a particular cond-colour-combination this entry is), rspCrr (whether the participant named the correct colour), and rspTme (the reaction time for that response). These variables have to be assigned to the following fields: ID to \u201CVariables that identify the same unit\u201D (it is an unique identifier of each participant); cond, colour and rep to \u201CVariables that differentiate within an unit\u201D (representing all possible combinations of experimental conditions); rspCrr and rspTme to \u201CVariables to be transformed\u201D (these measurements are repeated for each combination of conditions, and in a result we want a column each for all possible combinations of those variables and the experimental conditions, i.e., within-subject variables); and finally sex to \u201CVariables NOT to be transformed\u201D (since sex is a between-subjects variable that doesn't change between experimental condition, we thus only need one column in the output; however, it is not unique and thus not suited as ID variable).</p>\n"))}))

jtLong2WideBase <- if (requireNamespace("jmvcore", quietly=TRUE)) R6::R6Class(
    "jtLong2WideBase",
    inherit = jmvcore::Analysis,
    public = list(
        initialize = function(options, data=NULL, datasetId="", analysisId="", revision=0) {
            super$initialize(
                package = "jTransform",
                name = "jtLong2Wide",
                version = c(1,0,0),
                options = options,
                results = jtLong2WideResults$new(options=options),
                data = data,
                datasetId = datasetId,
                analysisId = analysisId,
                revision = revision,
                pause = NULL,
                completeWhenFilled = TRUE,
                requiresMissings = FALSE,
                weightsSupport = 'auto')
        }))

#' Transform dataset from long to wide
#'
#' Transform dataset from long to wide
#'
#' @examples
#' \dontrun{
#' # the function is a wrapper for jmvReadWrite::long2wide_omv
#' # please use that function when in R (or in Rj)
#' # for more information: https://sjentsch.github.io/jmvReadWrite
#'}
#' @param data .
#' @param varID .
#' @param varTme .
#' @param varTgt .
#' @param varExc .
#' @param varOrd .
#' @param varAgg .
#' @param varSep .
#' @param btnOut .
#' @return A results object containing:
#' \tabular{llllll}{
#'   \code{results$txtPvw} \tab \tab \tab \tab \tab a preformatted \cr
#'   \code{results$txtInf} \tab \tab \tab \tab \tab a html \cr
#' }
#'
#' @export
jtLong2Wide <- function(
    data,
    varID,
    varTme,
    varTgt,
    varExc,
    varOrd = "times",
    varAgg = "mean",
    varSep = "_",
    btnOut) {

    if ( ! requireNamespace("jmvcore", quietly=TRUE))
        stop("jtLong2Wide requires jmvcore to be installed (restart may be required)")

    if ( ! missing(varID)) varID <- jmvcore::resolveQuo(jmvcore::enquo(varID))
    if ( ! missing(varTme)) varTme <- jmvcore::resolveQuo(jmvcore::enquo(varTme))
    if ( ! missing(varTgt)) varTgt <- jmvcore::resolveQuo(jmvcore::enquo(varTgt))
    if ( ! missing(varExc)) varExc <- jmvcore::resolveQuo(jmvcore::enquo(varExc))
    if (missing(data))
        data <- jmvcore::marshalData(
            parent.frame(),
            `if`( ! missing(varID), varID, NULL),
            `if`( ! missing(varTme), varTme, NULL),
            `if`( ! missing(varTgt), varTgt, NULL),
            `if`( ! missing(varExc), varExc, NULL))


    options <- jtLong2WideOptions$new(
        varID = varID,
        varTme = varTme,
        varTgt = varTgt,
        varExc = varExc,
        varOrd = varOrd,
        varAgg = varAgg,
        varSep = varSep,
        btnOut = btnOut)

    analysis <- jtLong2WideClass$new(
        options = options,
        data = data)

    analysis$run()

    analysis$results
}

